<!DOCTYPE html>
<html>
	<head>
		<title>Falling</title>
		<meta charset='utf8'>
		<style>
			body {
				margin:0;
				padding:0;
				font-family:sans-serif;
			}
			.inner {
				width:984px;
				margin:0 auto;
			}
			#canvas-container {
				border:2px solid #ccccd3;
				position:relative;
				height:551px;
			}

			canvas{
				position:absolute;
				top:0;
				left:0;
				visibility:hidden;
			}
		</style>
	</head>
	<body>
		<div class="inner">
			<h1>Falling</h1>
		</div>
		<div class="inner">
			<div id="canvas-container">
				<canvas width="980" height="551">
				</canvas>
				<canvas width="980" height="551">
				</canvas>
			</div>
			<button id="stop">  â—¼ Stop</button>
		</div>
		<script src="http://documentcloud.github.com/underscore/underscore.js"> </script>
		<script>
			_.mixin({
				'randBetween': function(min, max) {
					return Math.floor(Math.random() * (max - min + 1)) + min;
				},
				'round': function(numbah, digitz) {
					var scalesies = Math.pow(10, digitz);
					return Math.floor(numbah * scalesies) / scalesies;
				},
				'isPrimitive': function(val) {
					return _.isString(val) || _.isNumber(val);
				},
				'repeatStr': function(str, times) {
					return new Array(times + 1).join(str);
				},
				'inherits': function(parent, protoProps, staticProps) {
					var child;

					var ctor = function(){};
					// The constructor function for the new subclass is either defined by you
					// (the "constructor" property in your `extend` definition), or defaulted
					// by us to simply call the parent's constructor.
					if (protoProps && protoProps.hasOwnProperty('constructor')) {
						child = protoProps.constructor;
					} else {
						child = function(){ parent.apply(this, arguments); };
					}

					// Inherit class (static) properties from parent.
					_.extend(child, parent);

					// Set the prototype chain to inherit from `parent`, without calling
					// `parent`'s constructor function.
					ctor.prototype = parent.prototype;
					child.prototype = new ctor();

					// Add prototype properties (instance properties) to the subclass,
					// if supplied.
					if (protoProps) _.extend(child.prototype, protoProps);

					// Add static properties to the constructor function, if supplied.
					if (staticProps) _.extend(child, staticProps);

					// Correctly set child's `prototype.constructor`.
					child.prototype.constructor = child;

					// Set a convenience property in case the parent's prototype is needed later.
					child.__super__ = parent.prototype;

					return child;
				},
			});
		</script>
		<script>
			window.Falling = {
				'gameSpeed': -.1,
			};
		</script>
		<script src="Game.js"></script>
		<script src="Drawable.js"></script>
		<script src="InputManager.js"></script>
		<script>
			(function() {
				Falling.Background = _.inherits(Falling.Drawable, {
					'image': null,
					'ready': false,
					'constructor': function(initialState) {
						this.constructor.__super__.constructor.call(this, initialState);

						this.image = new Image();
						this.image.onload = _.bind(function() {
							this.ready = true;
						}, this);
						this.image.src = 'game-bg.jpg';
					},
					'doDraw': function(centroid, dT, game) {
						if(!this.ready) return;
						if(centroid.y <= 0) 
							centroid.y = game.height;

						var topSegment = this.image.naturalHeight - centroid.y;

						game.backbufferContext.drawImage(this.image, 0, topSegment, this.image.naturalWidth, centroid.y, 0, 0, game.width, centroid.y);
						game.backbufferContext.drawImage(this.image, 
							/* sx */0, /* sy */ 0, 
							/* sw */ this.image.naturalWidth, /* sh */ topSegment, 
							/* dx */ 0,  /* dy */ centroid.y,
							/* dw */ game.width, /* dh */ topSegment
						);
					}
				});

				Falling.Obstacle = _.inherits(Falling.Drawable, {
					'segments': [],
					'constructor': function(spec, game) {
						this.state = _.extend( { }, this.state, _.pick(spec, ['y']), { vY: Falling.gameSpeed });

						this.height = spec.height;

						this.segments = [];
						if(spec.holePos < 80) {
							this.segments.push({
								'x': 80,
								'width': game.width - 80
							});
						} else if (spec.holePos > (game.width - 80)) {
							this.segments.push({
								'x': 0,
								'width': game.width - 80
							});
						} else {
							this.segments.push({
								'x': 0,
								'width': spec.holePos
							});
							this.segments.push({
								'x': spec.holePos + 80,
								'width': game.width - spec.holePos - 80
							});
						}
					},
					'doDraw': function(centroid, dT, game) {
						game.backbufferContext.beginPath();

						this.segments.forEach(function(seg) {
							game.backbufferContext.moveTo(seg.x, centroid.y);
							game.backbufferContext.lineTo(seg.x + seg.width, centroid.y);
							game.backbufferContext.lineTo(seg.x + seg.width, centroid.y + this.height);
							game.backbufferContext.lineTo(seg.x, centroid.y + this.height);
							game.backbufferContext.closePath();
						}, this);

						game.backbufferContext.fill();
					}
				});

				Falling.Player = _.inherits(Falling.Drawable, {
					'doDraw': function(centroid, dT, game) {
						if(game.inputManager.keyDown(game.inputManager.Keys.LEFT)) {
							centroid.x -= 40;
						}

						if(game.inputManager.keyDown(game.inputManager.Keys.RIGHT)) {
							centroid.x += 40;
						}
						if(centroid.x - 5 < 0) {
							centroid.x = 20;
						}
						if(centroid.x + 5 >= game.width) {
							centroid.x = game.width - 6;
						}

						this.constructor.__super__.doDraw.call(this, centroid, dT, game);
					}
				});

				window.requestAnimationFrame = window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.msRequestAnimationFrame || 
					function(func) { window.setTimeout(func, 1000/60); } 

				Falling.game = new Falling.Game('c');
				Falling.game.draw();

				document.getElementById('stop').addEventListener('click', function() {
					Falling.game.stop = true;
				});

			})();
		</script>
	</body>
</html>
